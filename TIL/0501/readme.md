# 컴퓨터 구조


목표?

상위 수준의 프로그램
- 어떻게 번역되고, 어떻게 실행될까?

하드웨어와 소프트웨어 사이의 인터페이스

프로그램 성능을 결정하는 요소는?
어떻게 성능을 개선할 수 있을까?


프로세서와 메모리 시스템: 명령어 실행 속도 결정
입출력 시스템: 입출력 작업의 실행 속도를 결정

컴퓨터 구조 분야에서 발명된 7개의 아이디어
1. 추상화
- 상세한 사항(구체적인 것)을 인터페이스라는 상위 수준 모델로 단순화한다.
- 구체적인 것을 숨긴다 == 설계를 단순화한다.
ex) 가상 메모리, ISA, …

2. 자주(흔한) 생기는 일을 빠르게
- 드물게 생기는 일을 최적화하는 것보다 성능 개선에 도움이 된다.
ex) 캐시, jit 컴파일러

3. 병렬성을 통한 성능 개선
- 작업을 병렬적으루 수행하여 성능을 높이는 설계
- 파이프라인, 멀티코어, 멀티 스레드

4. 파이프라이닝을 통한 성능 개선
- 컴퓨터 구조에서 많이 볼 수 있는 병렬성의 특별한 형태

5. 예측을 통한 성능 개선
- 예측이 틀렸을 때 이를 복구하는 비용이 비싸지 않고 예측이 맞을 확률이 비교적 높은 경우 확실해질 때까지 기다리는 것보다 예측해서 일단 시작하는 것이 평균적으로 더 빠를 수 있다.
ex) branch 예측, 

6. 메모리 계층 구조
- 속도 vs 크기 vs 비용
- 상충되는 요구를 “메모리 계층 구조”로 해결하고 있다.
- 최상위 계층 : 가장 빠르고, 가장 작고, 제일 비싼 메모리
- 최하위 계층 : 가증 느리고, 가장 크기ㅗ, 비트당 가격이 제일 쌈
- locality 를 잘 활용한다.
캐시: 프로그래머에게 최상위 계층만큼 빠르고 최하위 계층만큼 크면서 싼 메인 메모리가 있는 것 처럼 보이게 한다.



추상화
- 하드웨어와 소프트웨어 사이의 인터페이스를 구성하며, 하드웨어의 복잡성을 추상화하여 소프트웨어가 하드웨어를 쉽게 다룰 수 있도록 하는 것이다.

운영체제: 하드웨어와소프트웨어 사이의 인터페이스 역할
- 입출력 작업의 처리
- 보조 기억 장치(disk) 및 메모리 할당
- 컴퓨터를 동시에 사용하는 여러 응용들 간의 공유 방법 (time sharing)


컴파일러: 상위 수준 언어를 하드웨어가 실행할 수 있는 명령어인 기계어로 번역 

기계어: 1과 0인 이진수, 비트라고함, 
- 컴퓨터가 이해가능한 언어
- 명령어 (instuction): 컴퓨터가 이해할 수 있는 비트들의 집합
- 명령어와 데이터 ==> 모두 이진수

어셈블러: 기호로된 명령어(어셈블리어) —> 기계어(이진수)로 변환
- 높은 생산성

상위 수준 언어 —> (컴파일러 —> 어셈블리어) —> 기계어
- 컴파일러: 언어에 대한 추상화 제공

하드웨어: 데이터 입/출력, 데이터 처리, 데이터 저장 (4가지 기능)

컴퓨터의 고전적인 구성 요소 5가지 : 입력, 출력, 메모리, (데이터패스, 제어유닛: 프로세서)
—> 어느 컴퓨터의 어느 부분도 이 다섯 가지 요소중 하나에 대응한다.

프로세서(CPU): 프로그램의 지시(명령어)대로 일을 하는 부분으로, 보드 내에서 가장 역동적

논리적으로 데이터패스와 제어 유닛 두 부분으로 구성
- 데이터 패스: CPU안에서 데이터와 주소, 레지스터의 처리 및 연산을 하는 모든 요소
- ex) ALU, register, mem, …

- 제어 유닛: 할 일 지시

메모리?
- 프로세서 내부에 다른 종류의 메모리 == 캐시 메모리
- DRAM의 버퍼/캐시 역할, 작고 빠르다.
- SRAM, DRAM 메모리 계층 구조를 구성

제일 중요한 추상화 중 하나는 하드웨어와 최하위 소프트웨어 간의 인터페이스
- 명령어 집합 구조(ISA, 명령어, 입출력 장치 등이 포함)
- 인터페이스? 통신 매개체

입출력 장치, 메모리 할당 및 기타 저수준 시스템 기능의 세부사항
—> 운영체제가 프로그래머로부터 감추어서 프로그래머가 위의 세세한 부분을 고려하지 않아도 되도록 한다.

Application Binary Interface 라고 한다.
- 명령어 집합 구조 + 운영 체제

컴퓨터 설계자는 구조와 구조의 구현을 분리해서 생각할 수 있다.

정리: 여러 계층의 추상화 중에서 가장 중요한 것은 하드웨어와 하위 계층 소프트웨어 간의 인터페이스인 명령어 집합 구조라고 한다.
- 운영체제는 ???

참고: 추상화가 적용된 사례 중 일부 정리
- 운영체제: 하드웨어를 추상화하여 사용자와 애플리케이션 프로그램이 하드웨어를 쉽게 다룰 수 잇도록 한다. 예를 들어, 파일 시스템은 하드 드라이브의 세부적인 동작을 추상화하여 사용자가 파일을 쉽게 다룰 수 있도록 한다.
- 가상 메모리: 메모리의 추상화. 이를 통해 프로그래머는 메모리의 크기에 제한 없이 무한한 메모리를 가지고 있다고 가정하고 프로그램을 할 수 있다.
- 컴파일러: 상위 수준 언어를 기계어로 변환하기 때문에 프로그래머는 하드웨어의 세부 사항을 알 필요 없이 프로그래밍을 할 수 있다.
- ISA: 프로그래머와 컴파일러는 하드웨어의 세부 사항을 몰라다ㅗ ISA에 정의한 명령어를 사용하여 프로그램을 작성하고 컴파일 할 수 있다. 또한 ISA는 하드웨어와 소프트웨어 간의 호환성을 제공하며, 여러 제조업체가 다양한 하드웨어 구조를 만들 수 있도록 자유도를 보장한다.

휘발성 메모리(volatile): 메인 메모리
비휘발성 메모리(nonvolatile):  보조 기억 장치 (disk)
플레쉬 메모리(SSD): DRAM 보다 훨씬 싸고 비휘발성 + 디스크보다 작고 튼튼하며 전력소모가 적고 훨씬 소용량으로 생산될 수 있다.
- 자기 디스크와 달리 플레시 메모리는 10만번 ~. 00만번 쓰기 이후에는 못쓴다고 한다.
파일 시스템은 쓰기의 횟수를 파악하여 저장 기능이 상실되는 것을 피하도록 많이 사용되는 데이터를 이동시키는 등의 정책을 사용해야 한다.

컴퓨터 네트워크
- 컴퓨터 시스템 전체가 서로 연결

이더넷 (네트워크 중 가장 널리 알려짐)
- 대략 1 km 연결, 초당 100gb 전송 가능 (실질적인 네트워크)
- 한 건물의 같은 층에 있는 컴퓨터들을 연결하는데 유용하다.
- 근거리 네트워크(local network area, LAN)의 일종이다 (개념적인 네트워크)

라우팅 서비스와 보안을 제공하는 스위치/라우터 를 사용하면 LAN 끼리 연결이 가능하다.
—> WAN
원거리 네트워크 (Wide Area Network, WAN)은 여러 대륙을 연결 (개념적인 네트워크)
- 웹(world wide web)을 지원하고 있는 인터넷의 근간을 이룬다.
- 광섬유(optical fiber)로 구성하여 통신회사에서 임대

오늘날의 LAN: 1 Gbps ~ 100 Gpbs 까지의 용량을 제공
용량? 데이터 통신 전송 용량

오늘날의 WAN: 수백 kbps ~ Gbps 수준

현재 쓰이고 있는 무선 기술의 표준은 1.  1300 Mbps의 속도로 데이터 전송 가능

성능의 정의: 상황마다 다르다.
1. 컴퓨터 사용자 개인의 입장에서는 응답 시간 (response time), 즉 실행 시간이 중요하다.
- 응답 시간: 작업 개시 ~ 종료까지의 시간 == 실행 시간

2. 데이터 센터 관리자에게는 처리량(throughput), 혹은 대역폭 (bandwidth), 즉 일정하 시간 동안 처리하는 작업의 양이 더 중요하다.

이처럼 상황마다 다른 성능 측정 척도를 사용한다.
대부분의 실제 컴퓨터에서는 실행시간이나 처리량 중 하나가 변하면 다른쪽에도 영향을 미친다.
프로그램의 성능을 개선하기 위해서는 어떤 성능 척도들이 중요한지를 몬저 명확히 정의 후 성능 측정해야 한다.

CPU 시간의 성능 척도: 실행 시간
실행 시간 	= (프로그램의 CPU 클럭 사이클 수) / (클럭 속도)
		= (프로그램의 CPU 클럭 사이클 수) * (클락 사이클 시간)
CPU 클럭 사이클 수 = 명령어 수 X 명령어 당 평균 클럭 사이클 수 (CPI)

파이프라이닝: 명령어의 실행을 중첩시켜서 프로그램을 병렬적으로 빠르게 실행
- 명령어 수준 병렬성 (ILP)
- 프로그래머와 컴파일러는 하드웨어가 명령어를 순차적으로 실행시키는 것으로 여길 수 있다.

명시적 병렬 프로그램의 어려움
1. 성능 중시: 프로그래밍의 어려움을 가중
2. 병렬성으로부터 얻을 수 있는 성능의 이득을 침해하지 않도록 분할된 일을 스케줄링, 동기화, 조정하는 오버헤드가 작아야 한다.
—> 원하는 속도 개선을 얻기 위해서는 부하를 공평하게 분배해야 한다.
—> 통신 및 동기화 오버헤드를 줄이기 위한 주의 필요
참고: 참여자들 간의 통신 오버헤드 ?? 컨텍스트 스위칭

몇 가지 키워드
- 동기화: 병렬 태스크들 간의 조정
- 서브워드 병렬성: 원소들에 대한 연산을 병렬로 수행
- —> 연산 장치 (ALU)의 폭을 넓혀서 동시에 여러 값을 처리한다.

- 파이프라이닝: 여러 명령어들을 동시에 fetch, decode, execute, branch prediction
- —> multiple issue
- 하드웨어, 컴파일러: 명령어 재배치 (re-ordering)

캐시 일관성
- 모든 프로세서(cpu core)는 캐쉬를 가지고 있다. (L1 캐시 <—> L2는 공유 캐시 <<)
- 이런 모든 프로세서에 딸린 캐시들이 공유하는 데이터 값이 모두 같지 않을 수 있다. 
- ==> 동기화 이슈
- 이런 것 때문에 volatile, 메모리 팬스, 메모리 오더 등의 개념이 필요

RAID: 저장장치의 처리량을 크게 개선 시킴
+ 여유분의 디스크를 적절한 수만큼 가지고 있음으로 해서 신뢰성 개선

python vs C : C의 추상화 수준이 하드웨어에 훨씬 가깝다. 즉 추상화의 간격을 줄임으로써 훨씬 좋은 성능
1. 데이터 수준 병렬성
- C instrinsic (??) 을 통해 서브워드 병렬성을 사용하면 대략 8배 성능이 개선된다 한다.
2. 명령어 수준 병렬성
- 다중 명령어 내보니가와 비순차 실행 하드웨어를 활용하기 위해 순환문 펼치기를 사용
- loop unrolling?? 레지스터를 renaming을 함으로써 의존성을 제거하여 병렬성을 증가시킴
- multiple issue

3. 메모리 계층 최적화
- 캐시 블로킹(cache blocking)을 이용하면 큰 행렬의 경우 약 1.5배로 성능 개선

4. 스레드 수준 병렬성
- using openMP

암달의 법칙: 개선후 실행 시간 = ( 개선에 의해 영향을 받는 실행시간 / 개선의 크기) + 영향을 받지 않는 실행시간
- 일부분의 성능 개선으로 얻을 수 있는 전체 시스템 성능 증가는개선된 부분이 얼마나 많이 사용되느냐에 달려 있다.
- 어떤 함수의 소비되는 시간을 알고 이의 잠재적인 속도 개선을 안다면 암달 법칙으로 전체 성능 개선을 예측할 수 있다.

프로세서가 발전함에 따라 새롭게 중요시 되는 것
1. 병렬성(멀티 프로세서)
2. 메모리 계층 구조에 대해서 locality (시간/공간적 지역성)
- cache 

MIPS 어셈블리

a = b + c
add a, b, c

산술 명령어의 피연산자에는 제약이 있다.
—> only register

MIPS 구조에서 레지스터의 크기는 32비트 ==> 1워드

레지스터 개수는 한정적, 보통 32개
- 즉 산술 명령어의 피연산자는 32개의 32비트 레지스터중 하나이어야 한다.

32개로의 제한
- 설계 원칙 2: 작은 것이 더 빠르다.
레지스터가 아주 많아지면 전기 신호가 더 멀리까지 전달되어야 하므로 클럭 사이클 시간이 길어진다.

참고: 클럭 사이클
- register to another register 까지 신호 전달 시간/주기

왜 32개의 레지스터일까?
- 명령어의 설계를 단순화 할 수 있다. 
- 명령어의 설계 단순화 —> 프로세서 설계의 단순화로 이어진다.

in MIPS
- 변수 레지스터: $s0, $s1
- 임시 레지스터: $t0, $t1

예)
f = (g + h) - (i + j);
add $t0, $s1, $s2
add $t1, $s3, $s4
sub $s5, $t0, $t1

메모리 피연산자 <<< 중요
- 배열 or 구조체 같은 복잡한 자료구조
- 하나의 레지스터에 담을 수 없다.
- 프로세서는 소량의 데이터만을 레지스터에 저장 가능하다.
- 하지만 컴퓨터 메모리는 수십억개의 데이터를 저장할 수 있다.
- 구조체, 배열 —> 메모리에 보관

MIPS의 산술 연산은 레지스터에서만 실행되므로 메모리와 레지스터 간의 데이터를 주고받는 명령어가 있어야 한다.

데이터 전송 명령어 : 메모리 주소가 필요
- lw/sw

메모리 —> 레지스터 : 로드(load) (반대: store)

메모리 주소는 명령어의 상수 부분(offset)과 두 번째 레지스터 값의 합으로 이어진다.
예)
g = h + A[8];
lw, $t0, 8($s3) # $s3가 A 배열 시작 주소(A[0])

데이터 전송 명령어의 상수 부분
- offset 이라고 한다.

주소 계산을 위해 더해지는 레지스터
- 베이스 레지스터라고 한다.

대부분의 컴퓨터는 바이트 단위 주소 지정
워드 주소는 워드를 구성하는 4바이트 주소 중 하나르 선택
- 연속된 주소가 4 차이

MIPS 에서 워드의 시작 주소는 항상 4의 배수
- 정렬 제약: 메모리 내에서 데이터는 자연스러운 경계를 지켜서 정렬되어야 한다.
- 정렬을 사용하면 데이터 전송이 빨라진다.

주소 종류/방식
- 빅 엔디안: 최상위 바이트 주소를 워드 주소로한다.
- 리틀 엔디안: 최하위 바이트 주소를 워드 ㅈ ㅜ소로 한다.
MIPS: 빅 엔디안 주소 방식

바이트 주소의 사용—> 배열 인덱스에도 영향을 끼침
A[8] —> 32($s3)

컴파일러는 자주 사용되는 변수를 가능한 많이 레지스터에 놓고 나머지 변수는 메모리에 저장했다가 필요할 때 꺼내서 레지스터에 넣는다.
- 자주사용하지 않는 변수들을 메모리에 넣는 일 == 메모리 스필링

레지스터는 메모리보다 접근속도가 빠르다
메모리 데이터를 사용하려면 데이터 전송 이후 작업해야 하므로 명령어가 추가로 더 필요하다. (메모리로부터 데이터 읽는 시간 증가)
즉 레지스터는 메모리보다 접근 시간이 짧고 처리량도 많으므로 레지스터에 저장된 데이터를 사용하면 시간도 절약되고 사용하기도 간편, 그러므로 좋은 성능을 얻고 에너지를 절약하기 위해서는 컴파일러가 레지스터를 효율적으로 사용해야 한다.

상수(immediate): 피연사자중 하나가 상수인 산술 연산 명령어
- 수치(immediate) 피연산자라고 한다.

addi $s3, $s3, 4
- 상수 피연산자는 사주 사용되므로 상수 필드를 갖는 산술 연산 명령어를 사용하면 매번 메모리에서 상수를 가져오는 것보다는 연산이 훨씬 빠르고 에너지도 준다.

“0” = $zero (값 0으로 묶어두도록 구현)
- 오? 쓰이는 빈도가 높아서 상수를 명령어에 포함시키도록 하는 것이 자주 생기는 일을 빠르게 하라는 아이디어의 또 다른 예이다.
+ MIPS 는 음의 상수도 지원
+ 베이스 레지스터 = 인덱스 레지스터라고 부르기도 한다.

LSB(Least significant bit) : 가장 오른쪽 비트(0)
MSB(Most significant bit) : 가장 왼쪽 비트(1)

32비트
- 0 ~ 2^32 - 1 : 부호 없는 수의 범위

만약 특정 연산의 결과가 하드웨어에 구현된 오른쪽 비트만으로는 표현이 불가능하면 오버플로(overflow)가 발생한 것이다.

2의 보수법 (2’s complement)
- MSB (0: 양수, 1: 음수)
- 부호 비트(MSB)에는  -2 ^ 31 을 곱한다/ 나머지는 동일

중요:
 -num = ~num + 1


오버플로(overflow) in 부호 있는 수
- 숫자가 음수인데 MSB가 0
- 숫자가 양수인데 MSB가 1

부호 확장 (sign extension)
- 16 비트 to 32 비트
- 왜? lw/sw 같이 16비트의 주소를 32비트 레지스터와 계산해야 하기 때문에 16비트를 32비트로 확장시킨다.
- lw/sw 뿐만 아니라, branch, addi, … 16비트 이진수 —> 32비트 이진수로 변환이 필요할 수 있다.
- 32비트 레지스터와 계산하기 위함

부호 있는 수: 최상휘 비트 (부호 비트)를 반복하여 복사
부호 없는 수: 왼쪽 모두 0

C 언어: 
- int = signed int
- unsigned int

2의 보수법으로 표현된 양수가 실제로는 왼쪽에 끝없는 0을 보유한다.
마찬가지로 음수는 실제로는 왼쪽에 끝없는 1을 보유한다.
즉 부호확장은 단순히 이들 중 “일부”를 복원하는 것일 뿐이다.

명령어의 컴퓨터 내부 표현
- 숫자 사용
- 레지스터 사용
- ==> 레지스터: 숫자 매핑

명령어는 레이아웃을 가진다.
- 레이아웃: 명령어 형식 (instruction format)

ex)
add $t0, $s1, $s2
0 17 18 8 0 32
- 처음(0), 끝(32): add
- 17: 첫번째 피연산자인 $s1 번호
- 18: 두번째 피연산자인 $s2 번호
- 8: 계산 결과가 들어갈 dest 레지스터 번호

명령어 —> 숫자: 기계어, 기계 코드
- 인간이 일고 쓰게하기 위해 2진수로 쉽게 변환이 가능한 16진수가 사용되기도 한다.
- 2진수 4자리 <==> 16진수 1자리 대응

MIPS 명령어의 필드

산술/논리 연산 명령어의 format (R type)

op | rs  | rt  | rd | shamt | funct
op: 연산자 (명령어 종류)
rs: 첫번째 source
rt: 두번째 source
rd: 목적지 레지스터
shamt: shift, 자리이동량
funct: 기능(fuction), op 필드 —> 연산의 종류, funct 필드 —> 구체적으로 연산 지정
- 기능 코드라고 한다.
lw/sw: 레지스터 필드 2개와 상수 필드 하나 필요
- I type 명령어

I Type format
op | rs | rt | constant or address
- 상수는 +- 2^15 보다 클 수 없다.
- rt 필드: 적재 결과가 들어갈 목적지 레지스터 번호

중요: 어떤 type의 명령어 형식이든 첫번째 필드인 “op”를 보고 구분이 가능하다
- 하드웨어가 구분한다
- 이렇게 함으로써 하드웨어의 복잡도를 낮춘다.

ex) A[300] = h + A[300];

lw $t0, 1200($t1);
…

참고: 작은것이 빠르다. 왜? 탐색시간이 적으니까!

컴퓨터의 바탕 원리
1. 명령어는 숫자로 표현: 프로그램 —> 이진 파일
2. 프로그램은 메모리에 기억되어 있어서 데이터처럼 읽고 쓸 수 있다.

내장 프로그램
- 명령어(코드)와 데이터를 똑같이 취급함으로써 컴퓨터 시스템의 메모리 하드웨어와 소프트웨어가 모두 간단해짐

비트 단위 연산
- 비트를 워드로 묶는 작업: packing
- 워드를 비트단위로 나누는 작업: unpacking
- 논리 연산 명령어 (&, | , <<, >>, ~, ^)

shift
명령어: 
- sll (shift left logical): <<
- srl (shift right logical): >>
R 형식의 shamt: 자리 이동량 (shift amount)

ex) $t2 = $s0 << 4bits
- 0 | 0 | 16($s0) | 10($t2) | 4 (shamt) | 0

상수(immediate)는 산술 연산 뿐만 아니라 and, or 연산에서도 유용하다.
- andi, ori 명령어를 제공

참고: 비트필드(필드) —> 워드 (32bit) 안에서 정의
- 한 워드 내에서 여러 개의 필드를 정의할 수 있다. (논리 연산을 통해서, and, or, sll, srl)
- 이 때 각 필드는 최소 길이 1 비트의 부호 없는 정수이다.
ex) in java, ThreadPoolExecutor, int ctl

addi 와 달리 andi와 ori 는 16비트 상수를 32비트로 바꿀 때 상위 16비트에 무조건 0을 삽입


판단을 위한 명령어
- 입력 데이터나 연산 결과에 따라 다른 명령어를 실행할 수 있다.
- 보통 if, while, for, … 으로 표현

조건부 분기 (conditional branch)

beq reg1, reg2, L1
- r1 과 r2 가 같으면 L1 으로 점프
- branch if equal

bne ~ : r1과 r2가 다르면 L1으로 점프 (분기)
- branch if not equal

참고: 조건을 반대로 검사해서 then 부분을 건너뛰게 하는 것이 효율적이다.

ex) if (i == j) f = g + h; else f = g - h;
bne $s3, $s4, Else
add $s0, $s1, $s2

무조건 분기 (unconditional branch)
- jump (j)

어셈블러가 컴파일러나 어셈블리 언어 프로그래머의 귀찮은 분기 주소 계산을 대신해준다.
- 마치 lw/sw의 데이터 주소 계산을 해주는 것과 동일

컴파일러가 소스 프로그램이 없는 분기 명령어나 레이블을 만들어내는 경우가 많이 있다.
이런 것들을 일일히 표시하지 않아도 되는 것이 high level programming language 의 장점 중하나
- 추상화 <<<

순환문 (loop)
- 역시 조건 판단 기능이 중요
- while(조건)
- 조건부 분기 <<

ex) while(save[i] == k)
		i +=  1;

- i와 k, $s3, $s5, save시작 주소 - $s6

1. 첫번째 할일: save[i] 주소를 임시 레지스터로
- $t0($s6) 같은 형태는 안된다. offset은 반드시 상수로만

Loop: 	sll $t1, $s3, 2
		add $t1, $t1, $s6
		lw $t0, 0($t1)
		bne $t0, $s5, Exit
		addi $s3, $s3, 1
		j Loop
		Exit: ~


대소비교: slt (set on less than)
- 두 레지스터 값 비교 후 값들 1 or 0으로 세팅

ex)
slt $t0, $s3, $s4 # $t0 = 1 if $s3 < $s4

상수 피연산자는 비교에서도 많이 사용된다.
- slti

MIPS 컴파일러는 slt, slti, beq, bne + $zero 를 이용해서 모든 비교조건을 만들 수 있다.

비교 명령어에는 부호있는 수와 부호없는 수 두가지를 다룰 수 있어야 한다.
- slt, slti :부호 있는 정수 비교
- sltu, stliu : 부호 없는 정수 비교 

case/switch
1. switch 구현? if-then-else로 변경
2. 더 효율적인 구현
- 코드의 시작 주소를 표로 만듬 
- 점프 주소 테이블, 점프 테이블
- 인덱스만 계산
- 해당 주소를 찾아내어 레지스터에 적재 후 점프!!!
- jr 명령어 (jump register)

### 하드웨어의 프로시저 지원

프로시저, 함수
- 이해하기 쉽고, 재사용이 가능하도록 프로그램을 구조화하는 방법 중 하나이다.

파라미터(인수, 인자)는 프로시저(함수)에 값을 보내고, 결과를 받아오는 일, 즉 프로그램의 다른 부분 및 데이터와 프로시저 사이의 인터페이스 역할을 한다.

Java도 C가 필요로 하는 모든 것을 필요로 한다.
ex) psvm - String[] args

프로시저는 소프트웨어에서 추상화를 구현하는 방법 중 하나이다.
- 인터페이스 역할

프로시저 실행 단계
1. 프로시저가 접근할 수 있는 곳에 인수를 넣는다
2. 프로시저로 제어를 넘긴다.
3. 프로시저가 필요로 하는 메모리 자원을 획득
4. 필요한 작업/루틴 수행
5. 호출한 프로그램이 접근할 수 있는 장소에 결과값을 넣는다.
6. 프로시저는 프로그램내의 여러 곳에서 호출될 수 있으므로 원래 위치로 제어를 돌려준다.

프로시저 호출 관례에 따라서 레지스터를 할당 (by MIPS)
$a0 ~ $a3: 전달할 인수를 가지고 있는 인수 레지스터 4개
$v0 ~ $v1: 리턴 값을 갖게되는 값 레지스터 2개
$ra: 호출한 곳으로 리턴하기 위한 복귀 주소를 가지고 있는 레지스터 1개, 31번

프로시저를 위한 명령어: jal (jump and link)
- 지정된 주소로 점프하면서 동시에 다음 명령어의 주소를 $ra 레지스터에 저장
- 즉 $ra 복귀주소는 리턴한 뒤 실행할 명령어의 주소이다.

jal procedure_address
- 당연히 프로시저도 코드의 한 부분이고 주소를 가지고 있다.

복귀할 때 jr(jump register) 명령어 이용
- jr $ra

caller: 함수를 호출하는 프로그램
callee: 호출되는 프로그램 (프로시저, 피호출 프로그램)

호출 프로그램(caller)은 $a0 ~ $a3에 전달할 인수값을 넣은 후 jal X 명령을 이용해 프로시저 X로 점프한다.
피호출 프로그램은 계산/루틴을 끝낸 후 계산 결과를 $v0 ~ $v1 에 넣은 후 jr $ra 명령을 실행하여 복귀한다.

내장 프로그램은 현재 실행중인 명령어의 주소를 기억하는 레지스터를 필요로 한다.
- 그래야 복귀 주소(다음 실행할 명령어 주소)를 알 수 있기 때문이다.
이 레지스터의 이름은 명령어 주소 레지스터, 프로그램 카운터 PC 라고 한다.
jal 명령은 프로시저에서 복귀할 때 다음 명령어부터 실행하도록 PC + 4 를 $ra 에 저장

더 많은 레지스터의 사용
- 인수 레지스터 4개, 결과값 레지스터 2개  << 이것만으로 부족한 경우?
호출 프로그램이 사용하는 모든 레지스터는 복귀하기 전에 프로시저 호출 전의 상태로 되돌려 놓아야 한다.
- 레지스터 스필링?
- 스택 !!

스택에는 다음 프로시저가 스필할(?) 레지스터를 저장할 장소나 레지스터의 옛날 값이 저장된 장소를 표시하기 위해 최근 할당된 주소를 가리키는 포인터가 필요하다.
- 스택 포인터, $sp (29번), 스택의 탑을 가리킴
- 워드 단위로 조정된다. (push and pop)
- 스택은 높은 주소에서 낮은 주소로 성장
- push: 스택 포인터 값을 감소시킴
- pop: 스택 포인터 값을 증가시킴

$t0 ~ $t9: 프로시저 호출 시, 피호출 프로그램이 값을 보존해주지 않는 임시 레지스터
$s0 ~ $s7: 프로시저 호출 전 후의 값이 같게 유지되어야 하는 변수레지스터
- 피호출 프로그램이 이 레지스터를 사용하려면 원래 값을 저장했다가 원상복구 한다.

레지스터 스필링(기존값, 전달할 값을 따로 저장하는 것)을 많이 줄일 수 있다.

### 중첩된 프로시저
파라미터인 $a0나 복귀주소인 $ra 가 다른 프로시저를 호출함으로써 바뀌어야 한다면?
값이 보존되어야 할 모든 레지스터를 스택에 넣는 것이다.
- 호출 프로그램은 인수레지스터($a0 ~ $a3)와 임시 레지스터($t0 ~ $t9) 중 프로시저 호출 후에도 계속 사용하는 것은 모두 스택에 넣는다.
- 피호출 프로그램은 복귀 주소 레지스터 $ra 와 저장 레지스터 ($s0 ~ $s7)중에서 피호출 프로그램이 사용하는 레지스터를 모두 저장한다.
- 즉 호출 프로그램이 계속 사용 하려는 레지스터, 보존해야 되는 레지스터를 사용하려고 할 때 “기존” 레지스터 값을 스택에 저장하는 것이다.
- $sp 는 스택에 저장되는 레지스터 값 개수에 맞추어 조정

함수 루틴:					# 루틴 시작점
		addi $sp, $sp, -8 	# adjust stack for 2 item
		sw $ra, 4($sp)	# 호출 프로그램이 사용하는 $ra 저장
		sw $a0, 0($sp)	# 호출 프로그램이 사용하는 $a0 저장

- 이처럼 루틴 시작점에서 제일 먼저 스택 포인터를 감소(push<<)시킨 후에 호출 프로그램이 계속 사용할 레지스터($ra, $a0, $t0, $s0) 들을 저장한다.
- 저장된 레지스터, saved registers

C 변수: 데이터 형(type)과 저장 유형(storage class)
- 정수, 문자

저장 유형
- 정적(static): 프로시저 호출 전, 후 계속 존재
- 자동(automatic): 프로시저가 종료되면 없어진다.

정적? static?
- static 변수, 함수
- 모든 프로시저의 외부에 선언 (전역 <<)
- 나머지는 자동변수

정적 변수에 대한 접근을 단순화하기 위해 MIPS 소프트웨어는 전역 포인터($gp, 28)을 사용한다,

피호출 프로그램이 $sp 보다 위쪽에는 값을 쓰지 못하게 함으로써 $sp 윗부분의 스택을 원상태로 유지한다.
- << 이 부분이 달라짐

새 데이터를 위한 스택 공간의 할당
- 레지스터에 들어가지 못할 만큼 큰 배열이나 구조체 같은 “지역변수”를 저장하는데도 스택이 사용
- 프로시저의 저장된 레지스터와 지역변수를 가지고 있는 스택 영역을 프로시저 프레임, 액티베이션 레코드라고 부른다.
- 프레임 포인터(frame pointer, $fp)가 프로시저 프레임의 첫번째 워드를 가리킴
- 스택 포인터 값이 프로시저 내에서 바뀔 수 있도록 해서 메모리 내 지역변수에 대한 변위(위치)는 변수가 프로시저 어느 부분에서 사용되느냐에 따라 달라질 수 있다.
- 프레임 포인터를 사용하면 프레임 포인터가 변하지 않는 베이스 레지스터의 역할을 하므로 지역변수 참조가 간단해진다.
- 별도의 프레임 포인터 여부와 상관없이 액티베이션 레코드는 항상 존재

$fp (30)는 프레임의 첫번째 워드
$sp (29)는 스택의 맨 위 (변할 수 있다.)
지역 변수 참조는 변하지 않는 $fp를 사용
프레임 포인터를 사용하는 경우 호출할 때의 $sp값으로 $fp 초기화, 나중에 $fp로 $sp를 원상 복구

정리
- $fp 는 스택, 프로시저 프레임의 베이스 포인터 역할을 한다. 변하지 않는다.
- $fp 는 $sp 로부터 초기화 된다.
- 루틴 시작점에 $sp 를 조정하면서 호출 프로그램(caller)가 사용할 레지스터들을 스택에 저장한다.
- 그 이후 사용할 지역 변수들을 $sp 를 조정하면서 저장한다.

새 데이터를 위한 힙 공간의 할당
- 자동 변수(지역 변수)외에도 정적 변수와 동적 자료구조를 위한 메모리 공간이 필요하다.
- 스택은 아님

MIPS의 메모리 할당 방식
- 최하위: 사용 예약 (커널코드인가?)
- Text: MIPS 기계어 (text segment)
- Data: 상수와 정적(static) 변수, 함수 (static data segment)
- Heap: 동적 데이터 (늘어났다 ~ 줄었다.)

스택과 힙을 마주보게 함으로써 메모리를 효율적으로 사용
in C: malloc, free
in Java, 자동 할당 해제(by gc) 
- 이 gc를 지원함으로 자바는 개발의 편의성을 얻었지만? 매우 느려졌다~

인수가 4개보다 많을 때는 MIPS에서는 나머지 인수를 프레임 포인터 바로 위 스택에 넣는 것이다.
즉 프로시저의 처음 네 인수 $a0 ~ $a3 에 있고, 나머지는 프레임 포인터를 통해 접근할 수 있는 메모리에 적재
$fp는 변하지 않으므로 변수 접근에 매우 편리함을 가진다.

Java의 문자/문자열
- 유니코드는 인간이 사용하는 거의 모든 언어의 자모를 수용할 수 있는 범용 인코딩 방식이다.
- java는 포괄성을 위해 문자를 유니코드로 표현 —> 16비트 (not 8비트, 1바이트)

lh 
- load half
- 워드의 반인 16비트를 읽어와서 우측 16비트에 넣는다.
- 부호 있는 수로 취급, 남은 16비트는 부화학장으로 채운다.

lhu: 부호 없는 수

sh: 
- store half
- 레지스터의 우측 16비트를 메모리에 쓴다.

C는 문자열의 종료를 ‘\0’ 으로 표시
java는 문자열의 종료를 길이를 표시하는 워드로 해결한다.
- java의 배열 표시와 같음

데이터는 인코딩되어 있다.
- 데이터가 사용되는 컨텍스트를 알아야 한다.

110100001100
- 부호 없는 정수 해석
- 부호 있는 정수 해석
- ASCII 문자열로 해석
- 명령어로 해석

이처럼 어떤 컨텍스트에서 사용되는지에 따라 값이 달라지기 때문에 반드시 컨텍스트를 알아야 한다!!

- 큰 상수가 필요 시 상위 16비트에 상수를 넣는 lui 명령어를 제공
- 하위 16비트는 그 다음에 나오는 다른 명령 ori 으로 채울 수 있다.

64비트도 마찬가지, 32비트씩 짤라서 저장
- 동기화 문제가 발생하기도 함
- 왜냐하면 명령어를 분리해서 저장하기 때문

컴파일러나 어셈블러는 큰 숫자를 직접 다룰 수 없기에 조각으로 나눈 후 재조립한다.
- MIPS 소프트웨어처럼 이 문제를 해결하도록 하면 큰 값을 만드는데 사용할 임시 레지스터를 제공할 수 있다.
- $at << 레지스터용 레지스터

### 32비트 수치 주소
- 어떻게 레지스터에 담을 수 있을까? 레지스터는 32비트인데?

분기와 점프 명령어에서의 주소 지정
I Type: 6비트 | 5비트 | 5비트 | 16비트
J Type: 6비트 | 26비트

주소가 16비트 혹은 26비트보다 클 수 없다.
그러면 그것보다 큰 주소는 어떻게 레지스터에 담을 수 있을까?

대안: PC = (특정 레지스터의 값) + (분기 주소)

조건부 분기: 
- 가까이 있는 명령어로 분기하는 경향이 있다.
- PC는 현 명령어의 주소를 가지고 있다.
- 즉 분기주소에 더할 특정 레지스터를 PC로 사용하면 현 위치에서 +=2^15 범위의 주소로 분기할 수 있다.
- 거의 모든 순환문과 if문의 분기 범위가 2^16 워드 이내이므로 PC는 이상적인 선택이다.

PC 상대 주소 지정
- HW 입장에서는 PC를 일찍 증가시켜 다음 명령어를 가리키게 하는 것이 편리하다.
- 그러므로 실제 MIPS 주소는 현 명령어 주소(PC)를 기준으로 하는 것이 아니고 다음 명령어 주소 (PC + 4)를 기준으로 하게 된다.

I Type 분기 주소: (PC + 4) + (16비트 주소)

무조건 분기:
- 가까이 있는 명령어로 분기할 이유가 없다.
- 즉 어디로든 갈 수 있다.

분기할 거리를 바이트 단위가 아니라 워드 단위로 나타내면 더 먼거리까지 분기할 수 있다.
- 워드 주소 사용 시 분기 거리를 4배 늘릴 수 있다.
- 26비트 필드를 바이트 주소로 해석하는 것이 아니라 워드 주소로 해석
- 그러면 28비트 바이트 주소로 나타낼 수 있다. (뒤에 0x00, << 2)

28비트 점프 주소를 사용하더라도 나머지 4비트를 채워야 한다. 
이 때도 PC를 이용
—> PC상위 4비트 + 28비트

근데 만약 점프 주소가 PC상위 4비트와 다르다면, 즉 이 경계를 넘어가야 하는 경우, 레지스터에 32비트 주소를 넣고 jr (점프 레지스터) 명령을 사용

거의 모든 조건부 분기의 목적지는 가까운 곳이지만, 가끔은 16비트로 나타낼 수 없는 먼 곳으로 분기하는 경우도 있다.
이런 경우 어셈블러는 큰 주소나 상수를 처리할 때처럼 같은 방법으로 처리
즉 분기 목적지로 가는 무조건 점프를 삽입 후, 분기 조건을 반대로 만들어서 이 점프를 건너뛸지를 결정

ex)
bne $s0, $s1, L1	 # L1이 매우 먼 곳일 때
—>
beq $s0, $s1, L2	# 조건을 반대로
j L1 				# 무조건 점프를 삽입 <<
L2:

주소 지정 방식
- 피연산자와 주소를 다양하게 사용하여 실제 주소를 나타내는 여러 방식

1. 수치(immediate) 주소 지정: 피연산자는 명령어 내에 있는 상수
2. 레지스터 주소 지정: 피연산자는 레지스터 (레지스터에 주소 존재)
3. 베이스(base)또는 변위(offset)주소 지정: 메모리 주소? 가 피연산자
- 메모리 주소는 레지스터와 명령어 내의 상수를 더해서 구한다.
4. PC 상대 주소 지정: (PC + 4) + offset
5. 의사 직접 주소 지정: PC[31:28] + 26비트(28비트)

data race (데이터 경쟁 관계)
- 다른 스레드들이 공유 메모리에 접근하고 그 중 적어도 하나가 쓰기 작업
- 예상치 못한 결과가 발생할 수 있다. (스레드 접근 순서에 따라서 결과가 달라짐
- 공유하는 영역 : 임계 영역

동기화 매커니즘을 제공해야 한다.
- lock, unlock

단 하나의 프로세서만이 작업할 수 있는 영역을 생성할 수 있다.
- 상호 배제

원자적으로 처리할 능력을 가진 하드웨어가 존재해야 한다.
+ 소프트웨어적 원자적 연산 제공해야 하기도 한다. 동기화 프리미티브

원자적 교환: 레지스터 값을 메모리 값과 교환
1. 단일 원자적 메모리 연산
2. 2개의 명령어 쌍으로 원자적 메모리 연산
- load linked, store condition : (1: 성공, 0: 실패)
- 만약 ll 명령어에 의해 명시된 메모리 주소의 내용이 같은 주소에 대한 sc명령어가 실행되기 전에 바뀐다면 sc명령 실패

원자적 교환은 멀티 프로세서 동기화를 위해 제시된 것이지만 다중 프로세스, 멀티 스레드를 다루는 데에도 적용된다.
- cas, getAndIncrement 같은 RMW 연산


























































